//@version=5
indicator("Tier 2 Pattern with Cascading Gates (CAPA)", overlay=true, shorttitle="T2DP_Cascaded")

// Plot EMAs on the chart
ema10_main  = ta.ema(close, 10)
ema20_main  = ta.ema(close, 20)
ema200_main = ta.ema(close, 200)
plot(ema10_main, title="EMA 10", color=color.blue)
plot(ema20_main, title="EMA 20", color=color.red)
plot(ema200_main, title="EMA 200", color=color.orange)

// Helper function defined at the top level
crosses(_ema) =>
    (low < _ema) and (high > _ema)

// Updated stateful Tier 2 pattern detection function
f_tier2Pattern() =>
    // EMA settings and calculations
    emaLen10  = 10
    emaLen20  = 20
    emaLen200 = 200
    ema10  = ta.ema(close, emaLen10)
    ema20  = ta.ema(close, emaLen20)
    ema200 = ta.ema(close, emaLen200)
    // Check EMA hierarchy: EMA10 > EMA20 > EMA200
    emaTrendOk = (ema10 > ema20) and (ema20 > ema200)
    
    // Persistent state variables
    var bool restricted       = false   // Set when the candle triggers a restriction
    var bool bearishCandidate = false   // Set when a bearish candidate is detected (waiting for confirmation)
    var bool justReset        = false   // True on the bar that resets restriction
    var bool permission       = false   // Signal permission flag
    
    // Reset justReset at the start of each bar
    justReset := false

    // If currently restricted, check if this candle resets the restriction
    if restricted
        // Reset if a bullish candle closes above EMA10
        if (close > open) and (close > ema10)
            restricted       := false
            justReset        := true
            bearishCandidate := false
            permission       := false

    // Pattern detection is run only if not restricted, not on the reset bar, and if the EMA trend is valid
    if not restricted and not justReset and emaTrendOk
        // Condition A: Single bullish candle that crosses EMA10 or EMA20 and closes above EMA10
        condA = (close > open) and ((crosses(ema10)) or (crosses(ema20))) and (close > ema10)
        
        // Condition B: Two-candle sequence
        // First, detect a bearish candidate candle
        condBearCandidate = (close < open) and ((crosses(ema10)) or (crosses(ema20))) and (close > ema10)
        if condBearCandidate
            bearishCandidate := true
        
        // Then, if the current candle confirms the candidate (bullish and closes above EMA10)
        condBConfirm = bearishCandidate and (close > open) and (close > ema10)
        
        // If either condition is met, permission is granted
        if condA or condBConfirm
            permission       := true
            bearishCandidate := false

    // After pattern detection, check if the current candle triggers restriction
    if not restricted and not justReset
        if (open < ema20) or (close < ema20)
            restricted       := true
            bearishCandidate := false
            // Don't reset permission here

    // Return true only if permission is granted, the bar is confirmed, and we're not restricted
    result = permission and barstate.isconfirmed and (not restricted)
    
    // Important: Only reset permission AFTER returning the result
    if result
        permission := false
        
    result

// Function to detect pattern on a specific timeframe
detectPattern(tf) =>
    request.security(syminfo.tickerid, tf, f_tier2Pattern())

// Get signals for each timeframe
daily_signal = detectPattern("D")
fourh_signal = detectPattern("240")
oneh_signal = detectPattern("60")
fifteenm_signal = detectPattern("15")
onem_signal = detectPattern("1")
tens_signal = detectPattern("10S")

// Create separate variables to track active patterns
var bool daily_active = false
var bool fourh_active = false
var bool oneh_active = false
var bool fifteenm_active = false
var bool onem_active = false
var bool tens_active = false

// Update daily pattern state
if daily_signal
    daily_active := true
else if barstate.isconfirmed
    daily_active := false

// Get daily pattern state for lower timeframes
daily_is_active = request.security(syminfo.tickerid, "D", daily_active ? 1 : 0, lookahead=barmerge.lookahead_on) == 1

// Update 4-hour pattern state
if fourh_signal and daily_is_active
    fourh_active := true
else if barstate.isconfirmed and (not fourh_signal or not daily_is_active)
    fourh_active := false

// Get 4-hour pattern state for lower timeframes
fourh_is_active = request.security(syminfo.tickerid, "240", fourh_active ? 1 : 0, lookahead=barmerge.lookahead_on) == 1

// Update 1-hour pattern state
if oneh_signal and daily_is_active
    oneh_active := true
else if barstate.isconfirmed and (not oneh_signal or not daily_is_active)
    oneh_active := false

// Get 1-hour pattern state for lower timeframes
oneh_is_active = request.security(syminfo.tickerid, "60", oneh_active ? 1 : 0, lookahead=barmerge.lookahead_on) == 1

// Update 15-minute pattern state
if fifteenm_signal and fourh_is_active
    fifteenm_active := true
else if barstate.isconfirmed and (not fifteenm_signal or not fourh_is_active)
    fifteenm_active := false

// Update 1-minute pattern state
if onem_signal and (fourh_is_active or oneh_is_active)
    onem_active := true
else if barstate.isconfirmed and (not onem_signal or (not fourh_is_active and not oneh_is_active))
    onem_active := false

// Update 10-second pattern state
if tens_signal and oneh_is_active
    tens_active := true
else if barstate.isconfirmed and (not tens_signal or not oneh_is_active)
    tens_active := false

// Draw labels based on current timeframe and pattern states
if timeframe.isdaily and daily_signal
    label.new(bar_index, high, "D", style=label.style_label_down, color=color.green, textcolor=color.white)

if timeframe.isintraday and timeframe.multiplier == 240 and fourh_signal and daily_is_active
    label.new(bar_index, high, "4h", style=label.style_label_down, color=color.orange, textcolor=color.white)

if timeframe.isintraday and timeframe.multiplier == 60 and oneh_signal and daily_is_active
    label.new(bar_index, high, "1h", style=label.style_label_down, color=color.red, textcolor=color.white)

if timeframe.isintraday and timeframe.multiplier == 15 and fifteenm_signal and fourh_is_active
    label.new(bar_index, low, "15m", style=label.style_label_up, color=color.orange, textcolor=color.white)

if timeframe.isintraday and timeframe.multiplier == 1 and onem_signal and (fourh_is_active or oneh_is_active)
    label.new(bar_index, low, "1m", style=label.style_label_up, color=color.red, textcolor=color.white)

if timeframe.isseconds and timeframe.multiplier == 10 and tens_signal and oneh_is_active
    label.new(bar_index, high, "10s", style=label.style_label_left, color=color.red, textcolor=color.white)

// Debug info - show all active patterns and signals
var label debugLabel = na
if barstate.islast
    label.delete(debugLabel)
    debugInfo = "Current TF: " + timeframe.period + 
               "\n---\nDaily Signal: " + str.tostring(daily_signal) +
               "\n4h Signal: " + str.tostring(fourh_signal) +
               "\n1h Signal: " + str.tostring(oneh_signal) +
               "\n15m Signal: " + str.tostring(fifteenm_signal) +
               "\n1m Signal: " + str.tostring(onem_signal) +
               "\n10s Signal: " + str.tostring(tens_signal) +
               "\n---\nDaily Active: " + str.tostring(daily_is_active) + 
               "\n4h Active: " + str.tostring(fourh_is_active) +
               "\n1h Active: " + str.tostring(oneh_is_active)
    debugLabel := label.new(bar_index, low - (low * 0.05), debugInfo, 
                           style=label.style_label_up, 
                           color=color.gray, 
                           textcolor=color.white,
                           size=size.small)
