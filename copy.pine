//@version=5
indicator("Tier 2 Pattern with Cascading Gates (CAPA)", overlay=true, shorttitle="T2DP_Cascaded")

// Plot EMAs on the chart
ema10_main  = ta.ema(close, 10)
ema20_main  = ta.ema(close, 20)
ema200_main = ta.ema(close, 200)
plot(ema10_main, title="EMA 10", color=color.blue)
plot(ema20_main, title="EMA 20", color=color.red)
plot(ema200_main, title="EMA 200", color=color.orange)

// Helper function defined at the top level
crosses(_ema) =>
    (low < _ema) and (high > _ema)

// Updated stateful Tier 2 pattern detection function
f_tier2Pattern() =>
    // EMA settings and calculations
    emaLen10  = 10
    emaLen20  = 20
    emaLen200 = 200
    ema10  = ta.ema(close, emaLen10)
    ema20  = ta.ema(close, emaLen20)
    ema200 = ta.ema(close, emaLen200)
    // Check EMA hierarchy: EMA10 > EMA20 > EMA200
    emaTrendOk = (ema10 > ema20) and (ema20 > ema200)
    
    // Persistent state variables
    var bool restricted       = false   // Set when the candle triggers a restriction
    var bool bearishCandidate = false   // Set when a bearish candidate is detected (waiting for confirmation)
    var bool justReset        = false   // True on the bar that resets restriction
    var bool permission       = false   // Signal permission flag
    
    // Reset justReset at the start of each bar
    justReset := false

    // If currently restricted, check if this candle resets the restriction
    if restricted
        // Reset if a bullish candle closes above EMA10
        if (close > open) and (close > ema10)
            restricted       := false
            justReset        := true
            bearishCandidate := false
            permission       := false

    // Pattern detection is run only if not restricted, not on the reset bar, and if the EMA trend is valid
    if not restricted and not justReset and emaTrendOk
        // Condition A: Single bullish candle that crosses EMA10 or EMA20 and closes above EMA10
        condA = (close > open) and ((crosses(ema10)) or (crosses(ema20))) and (close > ema10)
        
        // Condition B: Two-candle sequence
        // First, detect a bearish candidate candle
        condBearCandidate = (close < open) and ((crosses(ema10)) or (crosses(ema20))) and (close > ema10)
        if condBearCandidate
            bearishCandidate := true
        
        // Then, if the current candle confirms the candidate (bullish and closes above EMA10)
        condBConfirm = bearishCandidate and (close > open) and (close > ema10)
        
        // If either condition is met, permission is granted
        if condA or condBConfirm
            permission       := true
            bearishCandidate := false

    // After pattern detection, check if the current candle triggers restriction
    if not restricted and not justReset
        if (open < ema20) or (close < ema20)
            restricted       := true
            bearishCandidate := false
            // Don't reset permission here

    // Return true only if permission is granted, the bar is confirmed, and we're not restricted
    result = permission and barstate.isconfirmed and (not restricted)
    
    // Important: Only reset permission AFTER returning the result
    if result
        permission := false
        
    result

// --- Pattern detection on each timeframe ---
// Check if pattern triggers on current bar for each timeframe
is_daily_pattern = timeframe.isdaily and f_tier2Pattern()
is_fourh_pattern = timeframe.isintraday and timeframe.multiplier == 240 and f_tier2Pattern()
is_oneh_pattern = timeframe.isintraday and timeframe.multiplier == 60 and f_tier2Pattern()
is_fifteenm_pattern = timeframe.isintraday and timeframe.multiplier == 15 and f_tier2Pattern()
is_onem_pattern = timeframe.isintraday and timeframe.multiplier == 1 and f_tier2Pattern()
is_tens_pattern = timeframe.isseconds and timeframe.multiplier == 10 and f_tier2Pattern()

// --- Pattern state persistence for each timeframe ---
// These variables maintain state between bars
var bool daily_pattern_active = false
var bool fourh_pattern_active = false
var bool oneh_pattern_active = false
var bool fifteenm_pattern_active = false
var bool onem_pattern_active = false
var bool tens_pattern_active = false

// --- Update pattern states based on current timeframe ---
if timeframe.isdaily
    // On daily timeframe, set pattern state directly
    if is_daily_pattern
        daily_pattern_active := true
        label.new(bar_index, high, "D", style=label.style_label_down, color=color.green, textcolor=color.white)
    else
        // Reset pattern state if no pattern detected and bar is confirmed
        if barstate.isconfirmed
            daily_pattern_active := false
else
    // On non-daily timeframes, fetch daily pattern state
    daily_pattern_active := request.security(syminfo.tickerid, "D", daily_pattern_active ? 1 : 0, lookahead=barmerge.lookahead_on) == 1

// 4-hour timeframe
if timeframe.isintraday and timeframe.multiplier == 240
    // Set pattern state if pattern detected and daily pattern is active
    if is_fourh_pattern and daily_pattern_active
        fourh_pattern_active := true
        label.new(bar_index, high, "4h", style=label.style_label_down, color=color.orange, textcolor=color.white)
    else
        // Reset pattern state if no pattern detected or daily inactive
        if barstate.isconfirmed
            fourh_pattern_active := false
else
    // On non-4h timeframes, fetch 4h pattern state
    fourh_pattern_active := request.security(syminfo.tickerid, "240", fourh_pattern_active ? 1 : 0, lookahead=barmerge.lookahead_on) == 1

// 1-hour timeframe
if timeframe.isintraday and timeframe.multiplier == 60
    // Set pattern state if pattern detected and daily pattern is active
    if is_oneh_pattern and daily_pattern_active
        oneh_pattern_active := true
        label.new(bar_index, high, "1h", style=label.style_label_down, color=color.red, textcolor=color.white)
    else
        // Reset pattern state if no pattern detected or daily inactive
        if barstate.isconfirmed
            oneh_pattern_active := false
else
    // On non-1h timeframes, fetch 1h pattern state
    oneh_pattern_active := request.security(syminfo.tickerid, "60", oneh_pattern_active ? 1 : 0, lookahead=barmerge.lookahead_on) == 1

// 15-minute timeframe
if timeframe.isintraday and timeframe.multiplier == 15
    // Set pattern state if pattern detected and 4h pattern is active
    if is_fifteenm_pattern and fourh_pattern_active
        fifteenm_pattern_active := true
        label.new(bar_index, low, "15m", style=label.style_label_up, color=color.orange, textcolor=color.white)
    else
        // Reset pattern state if no pattern detected or 4h inactive
        if barstate.isconfirmed
            fifteenm_pattern_active := false
else
    // On non-15m timeframes, fetch 15m pattern state
    fifteenm_pattern_active := request.security(syminfo.tickerid, "15", fifteenm_pattern_active ? 1 : 0, lookahead=barmerge.lookahead_on) == 1

// 1-minute timeframe
if timeframe.isintraday and timeframe.multiplier == 1
    // Set pattern state if pattern detected and either 4h or 1h pattern is active
    if is_onem_pattern and (fourh_pattern_active or oneh_pattern_active)
        onem_pattern_active := true
        label.new(bar_index, low, "1m", style=label.style_label_up, color=color.red, textcolor=color.white)
    else
        // Reset pattern state if no pattern detected or neither 4h nor 1h active
        if barstate.isconfirmed
            onem_pattern_active := false
else
    // On non-1m timeframes, fetch 1m pattern state
    onem_pattern_active := request.security(syminfo.tickerid, "1", onem_pattern_active ? 1 : 0, lookahead=barmerge.lookahead_on) == 1

// 10-second timeframe
if timeframe.isseconds and timeframe.multiplier == 10
    // Set pattern state if pattern detected and 1h pattern is active
    if is_tens_pattern and oneh_pattern_active
        tens_pattern_active := true
        label.new(bar_index, high, "10s", style=label.style_label_left, color=color.red, textcolor=color.white)
    else
        // Reset pattern state if no pattern detected or 1h inactive
        if barstate.isconfirmed
            tens_pattern_active := false
else
    // On non-10s timeframes, fetch 10s pattern state
    tens_pattern_active := request.security(syminfo.tickerid, "10S", tens_pattern_active ? 1 : 0, lookahead=barmerge.lookahead_on) == 1

// Debug info - show active patterns for all timeframes
var label debugLabel = na
if barstate.islast
    label.delete(debugLabel)
    debugInfo = "Current TF: " + timeframe.period + 
               "\nDaily Active: " + str.tostring(daily_pattern_active) + 
               "\n4h Active: " + str.tostring(fourh_pattern_active) +
               "\n1h Active: " + str.tostring(oneh_pattern_active) +
               "\n15m Active: " + str.tostring(fifteenm_pattern_active) +
               "\n1m Active: " + str.tostring(onem_pattern_active) +
               "\n10s Active: " + str.tostring(tens_pattern_active)
    debugLabel := label.new(bar_index, low - (low * 0.03), debugInfo, 
                           style=label.style_label_up, 
                           color=color.gray, 
                           textcolor=color.white,
                           size=size.small)
